const path = require('path')
const fs = require('fs')
const crypto = require('crypto')
const Metro = require('metro')
const { metroBundle } = require('./metroBundle')
const { hermesBundle } = require('./hermesBundle')
const { commonBundleCommandOptions } = require('./commonBundleCommandOptions')
const { info } = require('./logger')
const { moduleId } = require('./moduleId')
const { getDependencies } = require('./getDependencies')
const { getChunksConfig } = require('./getChunksConfig')
const { getOutputDir, PLATFORMS, makeBundleName, makeSourcemapOutput } = require('./utils')

const chunks = async (_argv, cliConfig, cliOptions) => {
  const config = getChunksConfig(cliConfig)
  const chunks = config.chunks ?? config.filter(({ name }) => name == cliOptions.chunk)
  const platforms = cliOptions.platform ? [cliOptions.platform] : PLATFORMS
  const metroConfig = await Metro.loadConfig()

  for (const platform of platforms) {
    for (const chunkConfig of chunks) {
      const start = Date.now()
      const { name, entryFile } = chunkConfig
      const root = cliConfig.root
      const outputDir = getOutputDir(root, platform, chunkConfig)
      let deps = []
      if (!cliOptions.skipAssets) {
        deps = getDependencies({ platform, entryFile, root, chunkId: name })
      }

      fs.mkdirSync(outputDir, { recursive: true })
      makeFacadeFile(outputDir, chunkConfig, deps, metroConfig, moduleId(entryFile))

      if (cliOptions.skipChunks) {
        info(`Skipping "${name}" chunk because --skip-chunks is true (took ${Date.now() - start}ms)`)
        continue
      }

      if (!cliOptions.force) {
        const currentHash = readHash(outputDir, platform)
        if (cliOptions.skipAssets) {
          // If we skip assets, we need to get the dependencies here to get the hash
          deps = getDependencies({ platform, entryFile, root, chunkId: name })
        }
        const nextHash = await makeHash(deps)
        if (currentHash === nextHash) {
          info(`Skipping "${name}" chunk because it is already up to date (took ${Date.now() - start}ms)`)
          continue
        } else {
          writeHash(outputDir, nextHash)
        }
      } else {
        writeHash(outputDir, null)
      }

      info(`Bundling chunk "${name}" for platform "${platform}"`)

      const bundleOutput = makeBundleName(outputDir, platform)
      const sourcemapOutput = makeSourcemapOutput(outputDir, platform)

      metroBundle({
        ...cliOptions,
        sourcemapOutput,
        entryFile,
        isChunkBundle: true,
        bundleOutput,
        assetsDest: undefined,
        chunkId: name,
        root: cliConfig.root,
        platform,
      })

      info(`Bundling ${bundleOutput} with Hermes`)

      hermesBundle({
        input: bundleOutput,
        output: bundleOutput,
        sourcemap: sourcemapOutput,
      })

      info(`Bundling chunk "${name}" for platform "${platform}" took ${Date.now() - start}ms`)
    }
  }
}

const filterAssets = (deps, metroConfig) => {
  const exts = metroConfig.resolver.sourceExts
  return deps
    .filter((file) => !exts.some((ext) => file.endsWith(ext)))
    .filter((file) => {
      const [fileName] = path.basename(file).split('.')

      return ['@2x', '@3x'].every((suffix) => !fileName.endsWith(suffix))
    })
}

const makeFacadeFile = (outputDir, chunkConfig, deps, metroConfig, id) => {
  const assets = filterAssets(deps, metroConfig)
    .map((file) => `require('${path.relative(outputDir, file)}');`)
    .join('\n')
  const content = `
  // This file is generated by react-native-chunks during the chunking process.
  // Do not modify it manually.
  const { loadChunk, loadAssets } = require('react-native-chunks');
  loadChunk(require('./index.chunk'), '${chunkConfig.name}_sm-${chunkConfig.sourcemapOrder}');

  function assetFnWillNotBeCalled() {
    ${assets}
  }

  loadAssets(assetFnWillNotBeCalled);

  const dynamicRequire = require;

  module.exports = dynamicRequire(${id});
  `
  fs.writeFileSync(path.join(outputDir, `index.js`), content)
}

function makeHash(deps) {
  return new Promise((resolve, reject) => {
    const hash = crypto.createHash('sha256')

    // Helper function to read files and update hash
    const processFile = (index) => {
      if (index >= deps.length) {
        // Finalize the hash after processing all files
        return resolve(hash.digest('hex'))
      }

      const fileStream = fs.createReadStream(deps[index])

      fileStream.on('data', (data) => {
        hash.update(data)
      })

      fileStream.on('end', () => {
        processFile(index + 1) // Process the next file
      })

      fileStream.on('error', (err) => {
        reject(err)
      })
    }

    // Start processing the first file
    processFile(0)
  })
}

const META_FILE = 'meta.json'

const writeHash = (outputDir, hash) => {
  writeMeta(outputDir, { hash })
}

const readHash = (outputDir) => {
  const meta = readMeta(outputDir)
  return meta?.hash
}

const readMeta = (outputDir) => {
  const file = path.join(outputDir, META_FILE)
  if (!fs.existsSync(file)) {
    return {}
  }
  return JSON.parse(fs.readFileSync(file, 'utf8'))
}

const writeMeta = (outputDir, meta) => {
  const prevMeta = readMeta(outputDir)
  meta = { ...prevMeta, ...meta }
  fs.writeFileSync(path.join(outputDir, META_FILE), JSON.stringify(meta, null, 2))
}

const chunkCommand = {
  name: 'chunks',
  description: 'Bundle chunks',
  func: chunks,
  options: commonBundleCommandOptions,
}

module.exports = {
  chunks,
  chunkCommand,
}
